{
    "collab_server" : "",
    "contents" : "generate_matrix <- function(factorloadings = fload, chold = TRUE){\n  #fload <- as.matrix(hads[2:3],ncol = 2)\n  fload <- factorloadings\n  uniq <- 1-(fload[,1]**2+fload[,2]^2)\n  #uniq\n  #uniqeness calcultae\n  \n  fact <- sim.structure(fload, items = TRUE, uniq = uniq)\n  #fact\n  M <- fact$model\n  #M = round(fact$model,2)\n  if (chold == TRUE){\n    L= chol(M)\n    return(L)}\n  else{return(M)}\n}\n\nsimulate_data <- function(matrix, ncol = nobs){\n  rdata <- generate_matrix(matrix)\n  nvars <- dim(matrix)[1]\n  r = t(matrix) %*% matrix(rnorm(nvars*nobs), nrow=nvars, ncol=nobs)\n  r = t(r)\n  rdata = as.data.frame(r)\n  return(rdata)\n}\n\ncutfunc <- function(var, list_of_cut, data, rows=nobs){\n  df <- data.frame(matrix(ncol = 1, nrow = rows))\n  new_var = paste('int',var, sep = \"_\")\n  df[new_var] <- NA\n  cut <- quantile(unlist(data[var]), list_of_cut)\n  df[new_var][data[var] <= cut[1]] <- 1\n  for (n in 2:length(list_of_cut)-1){\n    df[new_var][(data[var] > cut[n]) & (data[var] <= cut[n+1])] <- n+1\n  }\n  df[new_var][(data[var] > cut[n+1])] <- n+2\n  return(df[new_var])\n}\n\nmake_int_data <- function(data = rdata, cutlist = df_cut){\n  varnames <- colnames(data)\n  len <- length(data) + 1\n  flag <- typeof(cutlist) == \"double\"\n  if (flag == 1){avector <- cutlist}\n  for (var in varnames){\n    if (flag != 1){avector <- unlist(cutlist[var])}\n    data[paste('int',var,sep = '_')] <- cutfunc(var = var, list_of_cut = avector, data = data)\n  }\n  int_data <- data[len:length(data)]\n  names(int_data) <- varnames\n  return(int_data)\n}\n\nmeasurment_error <- function(nrow, size){\n  temp <- c()\n  for (row in 1:nrow){\n    temp <- c(temp,runif(row-1, -size,size),1)\n    temp <- c(temp,(rep(NA,nrow-row)))\n  }\n  correl<-matrix(temp,ncol = nrow)\n  new <- t(correl)\n  diag(new) <- 1\n  new[upper.tri(new)] <- correl[upper.tri(correl)]\n  new_decomposed <- chol(new)\n  #error = t(new) %*% matrix(rnorm(nvars*nobs), nrow=nvars, ncol=nobs)\n  #data <- as.data.frame(error)\n  return(new_decomposed)\n}\n\ngetBiCop <- function(n, rho, mar.fun=rnorm, x = NULL, ...) {\n  if (!is.null(x)) {X1 <- x} else {X1 <- mar.fun(n, ...)}\n  if (!is.null(x) & length(x) != n) warning(\"Variable x does not have the same length as n!\")\n  \n  C <- matrix(rho, nrow = 2, ncol = 2)\n  diag(C) <- 1\n  \n  C <- chol(C)\n  \n  #X2 <- mar.fun(n)\n  X2 <- mar.fun(n,mean(x),sd(x))\n  X <- cbind(X1,X2)\n  \n  # induce correlation (does not change X1)\n  df <- X %*% C\n  \n  ## if desired: check results\n  #all.equal(X1,X[,1])\n  #cor(X)\n  return(df)\n}\n\nget_cor_var <- function(n = nobs, data = NULL, col = NULL, input = input.csv, var = NULL, items = NULL, R = NULL){\n  #R <- na.omit(input[col])[2,1]\n  DR <- na.omit(input[col])[1,1]  #desierd R\n  ar <- .01                      #accepted range of R\n  tmp_data <- data[items]\n  for (i in 1:length(tmp_data)){\n    tmp_data[i] <- getBiCop(n = nobs,rho = R,x = data[,var])[,2]\n    #tmp_data[i] <- round(getBiCop(n = nobs,rho = R,x = data[,var]),0)[,2]\n    #tmp_data[i] <- trunc(getBiCop(n = nobs,rho = R,x = data[,var]))[,2]\n    #tmp_data[i] <- getBiCop(n = nobs,rho = R,x = tmp_data[,var])[,2]\n    \n  }\n  #tmp_data[tmp_data < 0] <- 0\n  #tmp_data[tmp_data > 3] <- 3\n  tmp_data <- make_int_data(cutlist = mod_cut, tmp_data) - 1\n  new_sum <- rowSums(tmp_data)\n  \n  CR <- cor(rowSums(data[var]),new_sum)\n  if (CR <= (DR+ar) & (DR-ar) <= CR) {return(new_sum)\n  } else {\n    get_cor_var(n = nobs, data = data, col = col, input =input, var = var, items = items, R = R+.01)\n  }\n}\n",
    "created" : 1537012559415.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2978228336",
    "id" : "16A95B7C",
    "lastKnownWriteTime" : 1536909766,
    "last_content_update" : 1536909766,
    "path" : "C:/Users/Jon/Dropbox/Simulation_better/functions.R",
    "project_path" : "functions.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}